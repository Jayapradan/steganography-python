# -*- coding: utf-8 -*-
"""CLC.activity 3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SiSXGlEubw-ITvxfJEvJD5y4P9FUfYyp
"""

from PIL import Image
img = Image.new("RGB", (800, 600), color=(0, 120, 255))  # blue image
img.save("orig.png")
img

from google.colab import files
files.upload()

import os
os.rename("orig (1).png", "orig_uploaded.png")

with open("secret.txt", "w") as f:
    f.write("This is my hidden message inside the zip.")

import zipfile
with zipfile.ZipFile("secret.zip", "w") as z:
    z.write("secret.txt")

print("ZIP file created: secret.zip")

from google.colab import files
files.download("secret.zip")

!pip install pycryptodome

from Crypto.Cipher import AES
from Crypto.Protocol.KDF import PBKDF2
from Crypto.Util.Padding import pad, unpad
from PIL import Image
import os
import struct
import zlib
import secrets

def encrypt_data(data, password):
    salt = secrets.token_bytes(16)
    iv = secrets.token_bytes(16)
    key = PBKDF2(password, salt, dkLen=32, count=20000)

    encrypted = AES.new(key, AES.MODE_CBC, iv).encrypt(pad(data, AES.block_size))

    # New: Embed the length of the encrypted data
    encrypted_len = struct.pack('>I', len(encrypted))

    header = b"STEG"
    crc = struct.pack(">I", zlib.crc32(data))

    # New metadata format: salt (16) + iv (16) + header (4) + encrypted_len (4) + crc (4) + encrypted data
    return salt + iv + header + encrypted_len + crc + encrypted


def embed_lsb(image_path, output_path, data):
    img = Image.open(image_path).convert("RGB")
    pixels = img.load()

    bit_data = ''.join(format(byte, '08b') for byte in data)
    total_bits = len(bit_data)
    width, height = img.size

    max_bits = width * height * 3
    if total_bits > max_bits:
        raise ValueError("Data too large to embed.")

    idx = 0
    for y in range(height):
        for x in range(width):
            if idx >= total_bits:
                break

            r, g, b = pixels[x, y]

            if idx < total_bits:
                r = (r & 0xFE) | int(bit_data[idx])
                idx += 1
            if idx < total_bits:
                g = (g & 0xFE) | int(bit_data[idx])
                idx += 1
            if idx < total_bits:
                b = (b & 0xFE) | int(bit_data[idx])
                idx += 1

            pixels[x, y] = (r, g, b)

    img.save(output_path)
    print("Embedded successfully →", output_path)


def encode(image, file_to_hide, output, password):
    data = open(file_to_hide, "rb").read()
    encrypted = encrypt_data(data, password)
    embed_lsb(image, output, encrypted)


def extract_lsb(image_path):
    img = Image.open(image_path).convert("RGB")
    pixels = img.load()

    bits = []
    for y in range(img.height):
        for x in range(img.width):
            r, g, b = pixels[x, y]
            bits.extend([r & 1, g & 1, b & 1])

    byte_list = []
    for i in range(0, len(bits), 8):
        byte = 0
        for bit in bits[i:i+8]:
            byte = (byte << 1) | bit
        byte_list.append(byte)

    return bytes(byte_list)


def decrypt_data(blob, password):
    salt = blob[:16]
    iv = blob[16:32]
    header = blob[32:36]

    # New: Extract the embedded encrypted data length
    encrypted_len = struct.unpack('>I', blob[36:40])[0]
    crc32_orig = struct.unpack(">I", blob[40:44])[0]

    # The actual encrypted data starts after 44 bytes of metadata
    encrypted_data_full = blob[44:]

    if header != b"STEG":
        raise ValueError("No hidden file found.")

    # Use the extracted encrypted_len to get only the relevant encrypted data
    encrypted_data_actual = encrypted_data_full[:encrypted_len]

    key = PBKDF2(password, salt, dkLen=32, count=20000)

    cipher = AES.new(key, AES.MODE_CBC, iv)
    data = unpad(cipher.decrypt(encrypted_data_actual), AES.block_size)

    if zlib.crc32(data) != crc32_orig:
        raise ValueError("Wrong password or corrupted image.")

    return data


def decode(image, output_file, password):
    blob = extract_lsb(image)
    data = decrypt_data(blob, password)

    with open(output_file, "wb") as f:
        f.write(data)

    print("Successfully extracted →", output_file)

from PIL import Image

img = Image.new("RGB", (800, 600), color=(0, 120, 255))
img.save("orig.png")
img

encode("orig.png", "secret.zip", "output.png", "1234")

from google.colab import files
files.download("output.png")

from google.colab import files
files.upload()

decode("output.png", "recovered.zip", "1234")

files.download("recovered.zip")

from google.colab import files
files.download("orig.png")
files.download("output.png")